--- original/include/DataFrame/Internals/DataFrame_read.tcc	2025-03-19 12:19:13.750820321 +0000
+++ AIFM/include/DataFrame/Internals/DataFrame_read.tcc	2025-03-19 12:19:13.734820663 +0000
@@ -27,12 +27,16 @@
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
+#include "dataframe_vector.hpp"
+#include "deref_scope.hpp"
+
 #include <CSV/csv.hpp>
 #include <DataFrame/DataFrame.h>
 #include <DataFrame/Utils/FixedSizeString.h>
 
 #include <cstdlib>
 #include <functional>
+#include <memory>
 
 // ----------------------------------------------------------------------------
 
@@ -446,37 +450,45 @@
 // ----------------------------------------------------------------------------
 
 template <int IndexColNum, typename... ColTypes, typename... Strs>
-auto read_csv(std::string csv_file_path, Strs... data_col_names)
+auto read_csv(far_memory::FarMemManager* manager, std::string csv_file_path,
+			  Strs... data_col_names)
 {
     constexpr bool kUseDefaultIndex = (IndexColNum == -1);
-    using DefaultIndexType          = uint64_t;
+    using DefaultIndexType          = unsigned long long;
     using IndicatedIndexType =
         std::tuple_element<std::max(IndexColNum, 0), std::tuple<ColTypes...>>::type;
     using IndexType =
         std::conditional<kUseDefaultIndex, DefaultIndexType, IndicatedIndexType>::type;
-    StdDataFrame<IndexType> df;
-    auto vecs = io::parse_csv_to_vectors<ColTypes...>(csv_file_path, data_col_names...);
+    StdDataFrame<IndexType> df(manager);
+    auto vecs = io::parse_csv_to_vectors<ColTypes...>(manager, csv_file_path,
+													  data_col_names...);
     auto seq  = std::index_sequence_for<ColTypes...>{};
     if constexpr (kUseDefaultIndex) {
         IndexType num_rows;
-        std::vector<IndexType> index_vec;
+        auto index_vec = manager->allocate_dataframe_vector<IndexType>();
         [&]<typename T, T... ints>(std::integer_sequence<T, ints...> int_seq)
         {
             num_rows = std::max({std::get<ints>(vecs).size()...});
         }
         (seq);
+		far_memory::DerefScope scope;
+		auto kNumElementPerScope = 1024;
         for (IndexType i = 0; i < num_rows; i++) {
-            index_vec.push_back(i);
+			if (unlikely((i % kNumElementPerScope) == 0)) {
+				scope.renew();
+			}
+            index_vec.push_back(scope, i);
         }
         df.load_index(std::move(index_vec));
     } else {
         df.load_index(std::move(std::get<IndexColNum>(vecs)));
     }
     [&]<typename T, T... ints>(std::integer_sequence<T, ints...> int_seq,
-							   auto &vecs, auto strs)
+							   auto& vecs, auto strs)
     {
         (((IndexColNum != ints)
-              ? df.load_column(std::get<ints>(strs), std::move(std::get<ints>(vecs)),
+		  ? df.load_column(manager, std::get<ints>(strs),
+						   std::move(std::get<ints>(vecs)),
                                nan_policy::dont_pad_with_nans)
               : 0),
          ...);
